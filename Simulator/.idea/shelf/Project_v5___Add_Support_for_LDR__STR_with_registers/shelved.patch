Index: src/Instruction.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import java.io.IOException;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\nclass PresetInstruction implements Serializable {\n    String name;\n    private int opcode, specification, condition;\n    String operator;\n\n    static final long serialVersionUID=1L;\n\n    PresetInstruction(String name, int specification, int opcode, int condition, String operator) {\n        this.name=name;\n        this.opcode=opcode;\n        this.specification=specification;\n        this.condition=condition;\n        this.operator=operator;\n    }\n\n    boolean equals(int specification, int condition, int opcode) {\n        if (this.specification == specification && this.opcode == opcode) {\n            if(specification==2 && this.condition==condition) // Branch\n                return true;\n            else if(specification!=2)\n                return true;\n        }\n        return false;\n    }\n\n    @Override\n    public String toString() {\n        return name;\n    }\n}\n\npublic class Instruction {\n    private static ArrayList<PresetInstruction> presetInstructions=new ArrayList<>();\n\n    private Long instruction;\n    private int condition, specification, opcode, immediate, operand1, operand2, destination, offset;\n    private String name, operator;\n\n    String getName() {\n        return name;\n    }\n\n    Instruction(Long instruction) {\n        condition=-1;\n        specification=-1;\n        opcode=-1;\n        immediate=-1;\n        operand1=-1;\n        operand2=-1;\n        destination=-1;\n        offset=-1;\n\n        this.instruction=instruction;\n\n        // Bits 28-31\n        condition=(int)(instruction>>28)&(0xF);\n        // Bits 26-27\n        specification=(int)(instruction>>26)&(0x3);\n        // Bit 25\n        immediate=(int)(instruction>>25)&(0x1);\n\n        if(specification==0) {\n            // Bits 21-25\n            opcode = (int) (instruction >> 21) & (0xF);\n            // Bits 16-19\n            operand1 = (int) (instruction>>16) & (0xF);\n            // Bits 12-15\n            destination = (int) (instruction>>12) & (0xF);\n\n            if(immediate==0) {\n                // Bits 0-3\n                operand2 = (instruction.intValue()) & (0xF);\n            }\n            else {\n                // Bits 0-8\n                operand2 =  (instruction.intValue()) & (0xFF);\n            }\n        }\n        else if(specification==1) {\n            // Bits 20-25\n            opcode = (int) (instruction >> 20) & (0x1F);\n            // Bits 16-19\n            operand1 = (int) (instruction >> 16) & (0xF);\n            // Bits 0-12\n            operand2 = (instruction.intValue()) & (0xFFF);\n            // Bits 12-15\n            destination = (int) (instruction>>12) & (0xF);\n        }\n        else if(specification==2) {\n            // Bits 24\n            opcode = (int) (instruction >> 24) & (0x1);\n            // Bits 0-23\n            offset = (instruction.intValue()) & (0xFFFFFF);\n        }\n\n        for(PresetInstruction presetInstruction:presetInstructions) {\n            if(presetInstruction.equals(specification, condition, opcode)) {\n                name=presetInstruction.name;\n                operator=presetInstruction.operator;\n                break;\n            }\n        }\n        if(name==null)\n            System.out.println(\"Instruction Not Supported\\n\\n\");\n//        System.out.println(this);\n    }\n\n    void decode(int[] register_file) {\n        String one=\"DECODE: Operation is %s, First Operand is R%d, Second Operand is R%d, Destination Register is R%d \\nDECODE: Read Registers- R%d = %d, R%d = %d\\n\";\n        String two=\"DECODE: Operation is %s, First Operand is R%d, Second Immediate Operand is %d, Destination Register is R%d \\nDECODE: Read Registers- R%d = %d\\n\";\n        String ldr=\"DECODE: Operation is %s, Base Register is R%d, Destination Register is R%d, Offset is %d \\nDECODE: Read Register- R%d = %d\\n\";\n        String str=\"DECODE: Operation is %s, Base Register is R%d, Register whose value is to be stored in memory is R%d, Offset is %d \\nDECODE: Read Registers- R%d = %d, R%d = %d\\n\";\n        String branch=\"DECODE: Operation is %s\\n\";\n\n        if(specification==0) {\n            if(immediate==0)\n                System.out.printf(one, name, operand1, operand2, destination, operand1, register_file[operand1], operand2, register_file[operand2]);\n            else\n                System.out.printf(two, name, operand1, operand2, destination, operand1, register_file[operand1]);\n        }\n        else if(specification==1) {\n            if(name.equals(\"LDR\")) {\n                if(immediate==0)\n                    System.out.printf(ldr, name, operand1, destination, operand2, operand1, register_file[operand1]);\n                else if(immediate==1)\n                    System.out.printf(ldr, name, operand1, destination, register_file[operand2], operand1, register_file[operand1]);\n            } else if(name.equals(\"STR\")) {\n                if(immediate==0)\n                    System.out.printf(str, name, operand1, destination, operand2, operand1, register_file[operand1], destination, register_file[destination]);\n                else if(immediate==1)\n                    System.out.printf(str, name, operand1, destination, register_file[operand2], operand1, register_file[operand1], destination, register_file[destination]);\n            }\n        }\n        else if(specification==2)\n            System.out.printf(branch, name);\n    }\n\n    private int compute(int[] register_file) {\n        int a=register_file[operand1];\n        int b=operand2;\n        if(immediate==0)\n            b=register_file[operand2];\n        switch (operator) {\n            case \"&\":\n                return a & b;\n            case \"^\":\n                return a ^ b;\n            case \"-\":\n                return a - b;\n            case \"+\":\n                return a + b;\n            case \"==\":\n                if (a == b) {\n                    Simulator.Z=1;\n                    Simulator.N=0;\n                    return 0;\n                }\n                if (a < b) {\n                    Simulator.N=1;\n                    Simulator.Z=0;\n                    return -1;\n                }\n                Simulator.Z=0;\n                Simulator.N=0;\n                return 1;\n            case \"|\":\n                return a | b;\n            case \"~\":\n                return ~b;\n            case \".\":\n                return b;\n        }\n        return -1;\n    }\n\n    int execute(int[] register_file, int[][] data_MEM) {\n        String one=\"EXECUTE: %s %d and %d\\n\";\n        String mov_one=\"EXECUTE: %s value of R%d i.e. %d to R%d\\n\";\n        String mov_two=\"EXECUTE: %s %d to R%d\\n\";\n\n        if(specification==0) {\n            if (immediate == 0) {\n                if(opcode==13 || opcode==15)\n                    System.out.printf(mov_one, name, operand2, register_file[operand2], destination);\n                else\n                    System.out.printf(one, name, register_file[operand1], register_file[operand2]);\n            }\n            else {\n                if(opcode==13 || opcode==15)\n                    System.out.printf(mov_two, name, operand2, destination);\n                else\n                    System.out.printf(one, name, register_file[operand1], operand2);\n            }\n\n            return compute(register_file);\n        }\n        else if(specification==1) {\n            int index=operand2/4;\n            if(opcode==25) {\n                if(immediate==0) {\n                    System.out.printf(\"EXECUTE: Load from Data Memory value of %d element from base %d to register R%d\\n\", index + 1, operand1, destination);\n                    return data_MEM[operand1][index];\n                }\n                else if(immediate==1) {\n                    System.out.printf(\"EXECUTE: Load from Data Memory value of %d element from base %d to register R%d\\n\", register_file[operand2], operand1, destination);\n                    return data_MEM[operand1][register_file[operand2]];\n                }\n            }\n            if(opcode==24) {\n                if(immediate==0)\n                    System.out.printf(\"EXECUTE: Store value in register R%d to the %d element from base %d in Data Memory\\n\", destination, index+1, operand1);\n                else if(immediate==1)\n                    System.out.printf(\"EXECUTE: Store value in register R%d to the %d element from base %d in Data Memory\\n\", destination, register_file[operand2], operand1);\n                return -2;\n            }\n        }\n        else if(specification==2) {\n            if(opcode==0) {\n                int rel;\n                int bit=(offset>>23) & (0x1);\n                if(bit==1) {\n                    rel = (0xFF000000) | (offset * 4);\n                } else\n                    rel=offset*4;\n\n                System.out.printf(\"EXECUTE: %s with offset = %d\\n\", name, offset);\n\n                if(condition==0 && Simulator.Z==1)\n                    register_file[15]+=4+rel;\n                else if(condition==1 && Simulator.Z!=1)\n                    register_file[15]+=4+rel;\n                else if(condition==11 && Simulator.N==1 && Simulator.Z==0)\n                    register_file[15]+=4+rel;\n                else if(condition==12 && Simulator.N==0 && Simulator.Z==0)\n                    register_file[15]+=4+rel;\n                else if(condition==13 && (Simulator.N==1 || Simulator.Z==1))\n                    register_file[15]+=4+rel;\n                else if(condition==10 && (Simulator.N==0 || Simulator.Z==1))\n                    register_file[15]+=4+rel;\n                else if(condition==14)\n                    register_file[15]+=4+rel;\n            }\n        }\n        return -1;\n    }\n\n    int memory(int[][] data_MEM, int result, int[] register_file) {\n        if(specification==3)\n            return result;\n\n        if(condition==14) {\n            if(opcode==25) {\n                if(immediate==0) {\n                    System.out.printf(\"MEMORY: Load value %d from memory\\n\", data_MEM[operand1][operand2 / 4]);\n                    result = data_MEM[operand1][operand2 / 4];\n                }\n                else if(immediate==1) {\n                    System.out.printf(\"MEMORY: Load value %d from memory\\n\", data_MEM[operand1][register_file[operand2]]);\n                    result = data_MEM[operand1][register_file[operand2]];\n                }\n            }\n            else if(opcode==24) {\n                if(result==-2) {\n                    result=register_file[destination];\n                    System.out.printf(\"MEMORY: Store value %d in memory\\n\", result);\n                    if(immediate==0)\n                        data_MEM[operand1][operand2/4]=result;\n                    else if(immediate==1)\n                        data_MEM[operand1][register_file[operand2]]=result;\n                }\n            }\n            else\n                System.out.println(\"MEMORY: No memory operation\");\n        }\n        else\n            System.out.println(\"MEMORY: No memory operation\");\n        return result;\n    }\n\n    void write_back(int[] register_file, int result) {\n        String write=\"WRITE-BACK: Write %d to R%d\\n\";\n        String no=\"WRITE-BACK: No write-back operation\";\n\n        if(specification==0) {\n            if(opcode==10)\n                System.out.println(no);\n            else {\n                register_file[destination]=result;\n                System.out.printf(write, result, destination);\n            }\n        }\n        else if(specification==1) {\n            if(opcode==25) {\n                register_file[destination]=result;\n                System.out.printf(write, result, destination);\n            }\n            else\n                System.out.println(no);\n        }\n        else if(specification==2)\n            System.out.println(no);\n        else\n            Simulator.swi_exit();\n    }\n\n    @Override\n    public String toString() {\n        String s=\"Instruction: \"+Long.toBinaryString(instruction)+\"\\n\";\n        s+=\"Name: \"+name+\"\\n\";\n        s+=\"Operator: \"+operator+\"\\n\";\n        s+=\"Condition: \"+Integer.toBinaryString(condition)+\"\\n\";\n        s+=\"Specification: \"+Integer.toBinaryString(specification)+\"\\n\";\n        s+=\"Opcode: \"+Integer.toBinaryString(opcode)+\"\\n\";\n        s+=\"Immediate: \"+Integer.toBinaryString(immediate)+\"\\n\";\n        s+=\"Operand 1: \"+Integer.toBinaryString(operand1)+\"\\n\";\n        s+=\"Operand 2: \"+Integer.toBinaryString(operand2)+\"\\n\";\n        s+=\"Destination Register: \"+Integer.toBinaryString(destination)+\"\\n\";\n        s+=\"Offset: \"+Integer.toBinaryString(offset);\n\n        return s;\n    }\n\n    static void deserialize() {\n        try {\n            Main.deserialize(presetInstructions);\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) throws IOException, ClassNotFoundException {\n        Scanner Reader=new Scanner(System.in);\n\n        Main.deserialize(presetInstructions);\n\n        Instruction instruction=new Instruction(Long.decode(Reader.next()));\n        instruction.decode(new int[16]);\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/Instruction.java	(revision 94398c2730aee19c129456b53991673606ad44cd)
+++ src/Instruction.java	(revision )
@@ -282,7 +282,7 @@
         return result;
     }
 
-    void write_back(int[] register_file, int result) {
+    void dwrite_back(int[] register_file, int result) {
         String write="WRITE-BACK: Write %d to R%d\n";
         String no="WRITE-BACK: No write-back operation";
 
